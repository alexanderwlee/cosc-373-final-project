\documentclass{article}

\usepackage{amsmath}
\usepackage{hyperref} % for reference links
\usepackage{natbib} % for bibliography

\title{COSC-373 Final Report: Bitcoin}
\author{Lee Jiaen, Hyery Yoo, and Alexander Lee}

\begin{document}

\maketitle

\section{Introduction}

Before Bitcoin, the only commerce system on the internet relied heavily on
trusted third parties to process electronic payments. Suppose Alice, a buyer,
wants to buy an item from Bob's e-commerce store. Alice would need to make an
online payment that relies on a financial institution or some trusted third
party to process the transaction. However, Alice may not trust such third
parties. Alice wishes for a way where her online payment can be sent directly to
Bob without going through a third party. While the previous system worked for
most transactions, it had a few significant inefficiency problems. Trusted
third-party financial intuitions cannot avoid mediating disputes, making it
impossible to have completely non-reversible transactions. Therefore, the need
for trust increases, and ``a certain percentage of fraud is accepted as
unavoidable''~\citep{Nakamoto08}. One could avoid these issues with the use of
physical currency. However, like Alice, many people would prefer a decentralized
version of electronic cash that allows any two willing parties to transact
directly without a trusted third party. This is the goal and motivation of
Bitcoin. The following paper describes how Bitcoin, an electronic payment
system, is based on cryptographic proof instead of trust, allowing for direct
transactions without trusted third parties or financial institutions.

\section{Preliminaries}

To understand Bitcoin, we first need to develop an understanding of the
fundamental building-blocks behind it: digital signatures and cryptographic hash
functions.

\subsection{Digital Signatures}

Suppose for example that Alice wants to send a message to Bob over a network.
How can Bob ensure that the message he received was from Alice and not from a
malicious actor like Eve? What Alice can do is append a \emph{digital signature}
to her message and send the message and signature to Bob, which allows Bob to
verify that the message he received was indeed from Alice.

The main idea behind digital signatures is as follows. Both Alice and Bob each
generate a \emph{private key} and \emph{public key} pair for themselves, where
each key is a array of bits and private keys are kept secret (i.e., only Alice
knows her private key and only Bob knows his private key). Producing a signature
involves a function $\mathsf{sign(msg, priKey)}$, which takes Alice's message
$\mathsf{msg}$ and private key $\mathsf{priKey}$ as inputs and outputs Alice's
signature $\mathsf{sig}$. Similarly, verifying the authenticity of the received
message involves a function $\mathsf{verify(msg, sig, pubKey)}$, which takes the
received message $\mathsf{msg}$, the signature $\mathsf{sig}$, and Alice's
public key $\mathsf{pubKey}$ as inputs and outputs \emph{true} if the signature
was produced using Alice's message and private key, and \emph{false} otherwise.
We will not discuss how the $\mathsf{sign()}$ and $\mathsf{verify()}$ functions
work in depth since such details are not the focus of this work.

Digital signatures have two required properties. First, the authenticity of
Alice's signature generated from her message and private key can be verified
easily using her corresponding public key. Secondly, it should be
computationally infeasible for someone like Eve to generate a valid signature
for Alice without knowing Alice's private key. That is, Eve has no better
strategy than guessing and checking if random signatures are valid using Alice's
message and public key. Assuming a 256 bit signature, the aforementioned brute
force strategy would require Eve to check $2^{256}$ signatures in the worst
case.

\subsection{Cryptographic Hash Functions}

A \emph{cryptographic hash function} is a hash function that takes as input data
of an arbitrary size, known as the \emph{message}, and outputs a bit array of a
fixed size, known as the \emph{hash}. In the case of the SHA256 cryptographic
hash function, the hash has a length of 256 bits.

Cryptographic hash functions ideally should have the following properties.
First, computing the hash of a given message should be quick. Second, generating
the message from only the hash should be computationally infeasible. Third,
finding two different messages that map to the same hash under the function
should also be infeasible. Fourth, slightly changing the message should change
the hash so much such that the old and new hashes seem uncorrelated. Similar to
digital signatures, the only way to find a message that produces a given hash is
to via a brute force approach of guessing and checking possible messages. Again,
assuming a 256 bit hash, this strategy would require $2^{256}$ hashes to check
in the worst case.

\section{Bitcoin}

The \emph{Bitcoin network} is a randomly connected overlay network of a few
thousand nodes, where nodes are controlled by various owners and perform the
same operation. In other words, the network is a homogeneous network without
central control. Each user of Bitcoin generates a private/public key pair. A
user is identified by their \emph{address}, which is derived from their public
key and used to receive funds in Bitcoin. All nodes in the Bitcoin network work
together to track each address' balance in bitcoins.

\section{Transactions}

Suppose we have a \emph{transaction}, where Alice is the sender and Bob is the
recipient. What is a transaction, and how does it work?

A \emph{transaction} is a data structure that describes the transfer of bitcoins
from spenders to recipients. The transaction consists of several inputs and
outputs. More specifically, the inputs are a tuple consisting of a reference to
a previously created output and a signature to the spending condition, proving
that the transaction creator has the permission to spend the referenced output.
Meanwhile, the outputs are a tuple composed of an amount in bitcoins and a
spending condition requiring a valid signature associated with the private key
of an address. The outputs of a transaction may assign less than the sum of
inputs, in which case the difference is called the transaction fee. The
transaction fee is used to incentivize other participants in the system.

An output has two states, unspent and spent, and can only be spent at most once.
When we sum up the bitcoin amounts of unspent outputs associated with an
address, we get the address balance, and the set of these unspent transaction
outputs is the shared state of Bitcoin.

Transactions can be in one of two states: unconfirmed or confirmed. Unconfirmed
transactions are incoming transactions from the broadcast that are added to a
pool of transactions called the memory pool. All transactions are broadcasted to
the entire Bitcoin network, with each node deciding whether or not to accept the
transaction. As a result, every node in the Bitcoin network holds a complete
replica of the shared state. The local replicas of this shared state may
temporarily diverge, but consistency is eventually reestablished.

Thus, for the transaction between Alice to Bob, the inputs are Alice's previous
unspent outputs and Alice's digital signature, which was created using her
private key. Meanwhile, the outputs of this transaction are the amount in
Bitcoins for Bob and the spending condition requiring a valid signature
associated with the private key of Bob's address. The transaction is then
broadcasted in the Bitcoin network and processed by every node that receives it.

\section{Doublespending Problem}

Suppose we now have another transaction from Alice to Charlie that attempts to
spend the same output as the transaction from Alice to Bob.
\emph{Doublespending} is a situation in which multiple transactions attempt to
spend the same output. However, only one transaction can be valid because
outputs can only be spent at most once. Doublespending occurs because the order
in which transactions are seen may not be the same for all nodes, and the
validity of transactions depends on the order in which the transactions arrive.
If a node sees two conflicting transactions, it considers only the first
transaction it sees valid and the second invalid. The second seen transaction is
invalid since it tries to spend an already present output. As a result,
different nodes in the network accept different transactions, making their
shared states inconsistent. If the problem of doublespending is not resolved,
the shared states of the Bitcoin network diverge. The problem is that there is
nothing preventing nodes from locally accepting different transactions that
spend the same output. Therefore, a conflict resolution mechanism is needed to
decide which of the conflicting transactions (only one transaction) should be
accepted by every node to achieve eventual consistency in the network.

\section{Proof-of-Work}

Bitcoin solves the double-spending problem using \emph{Proof-of-Work} (PoW). PoW
is a mechanism in which one party can prove to another that it has spent a
specific amount of computational effort by presenting a nonce $x$ (a bitstring)
to the PoW function $F_d(c,x)$, where $d$ is the difficulty (a positive number)
and $c$ is the challenge (a bitstring). Another party can confirm this PoW by
quickly checking that $F_d(c,x) =$ true for the given $x$. In general terms,
suppose that Alice and Bob both know a PoW function $F_d(c,x)$ with $d$ and $c$
given. Alice expends a certain amount of computation to find a $x$ such that
$F_d(c,x) =$ true. Alice presents her solution $x$ to Bob, and Bob checks the
solution by computing $F_d(c,x)$. The PoW function must be defined such that
verifying a solution $x$ is fast. Through this process, Alice proves to Bob that
she has expended the amount of computational work specified by difficulty $d$.

What does PoW look like in the context of Bitcoin? First, we must understand
blocks. A \emph{block} is a data structure that consists of a list of
transactions, a reference to a previous block, and a nonce. Reference to
previous block links blocks together such that they form a blockchain. A block
can be added to a chain by a node (called \emph{mining}) when it collects
transactions from the network and finds a valid nonce $x$ that satisfies the
Bitcoin PoW function:
\[
  F_d (c,x) = \text{SHA256}(\text{SHA256}(c|x)) < \frac{2^{224}}{d}.
\]
Simply put, a node must find a value $x$ that, when concatenated with a
node-specific challenge $c$ and hashed with the hash function SHA256 twice,
returns a hash that starts with a fixed number of zeroes. SHA256 is a
cryptographic hash function, so a valid nonce can only be found by iterating
over all possible values of $x$, requiring significant computational work to be
put in. Suppose Alice is a node who puts in the computational effort to find a
valid nonce $x$ and broadcasts the block containing $x$ to other nodes. Alice’s
PoW can be verified by another node Bob who sees Alice’s block. Bob is given the
values of $c$ and $x$, so he can quickly compute the hash and verify that the
result starts with the required number of zeroes.

\section{Network}

The Bitcoin network operates by each node in the network executing the same set
of protocols. All transactions are broadcasted to the network, and every node
works on collecting new transactions from the network into a block and finding a
valid nonce for the block. When a node finds the valid nonce, it broadcasts the
block to the network, adding the block to the end of the chain in effect. When
another node in the network learns about the new block, it checks that all
transactions in the block are valid. If they are, it accepts the block and works
an extending the chain by creating a new block with the hash of the accepted
block.

A goal of the Bitcoin network is for all its nodes to agree on a single state of
the network. The nodes achieve this by accepting the longest chain they see as
the true state of the network. If a node receives two conflicting versions of a
block, it works on extending the first block it receives and saves the other
block as a branch. If the node later learns that the branch has become longer
than the chain it was working on, it switches to extending the branch. Because
every block requires PoW in order to be added to the chain, the longest chain in
the network represents the greatest amount of collective computational effort,
i.e., majority decision. All nodes eventually receive and accept the longest
chain, so the network reaches consistency.

Let us now look at how the Bitcoin network solves the doublespending problem.
Suppose Alice attempts to doublespend by creating two transactions containing
the same output, and the two transactions are collected into two separate
blocks, Block 1 and Block 2. If one of the blocks, Block 1, is broadcasted to
the network and gets accepted by all nodes before Block 2 is broadcasted, Block
2 is rejected by all nodes because it contains an invalid transaction. Thus,
Alice’s doublespending attempt fails. In a more subtle case, suppose that Block
1 and Block 2 are broadcasted to the network (almost) simultaneously. Some of
the nodes in the network receive Block 1 first, so they accept Block 1 and
reject Block 2. The opposite is true for other nodes in the network. This
creates two conflicting chains in the network with some of the nodes working on
extending each of the chains. Suppose the majority of nodes accept Block 1. Then
the sum of the computational effort put into Block 1’s chain is greater than
that for Block 2’s chain, and Block 1’s chain grows faster. Eventually, every
node receives this longer chain, and Block 2’s chain becomes rejected by all
nodes, leaving only one of Alice’s transactions in the network.

\section{Conclusion}

We discussed in this report the fundamental structure of Bitcoin and how it
solves the doublesepnding problem. Other aspects of Bitcoin include
incentivizing miners, reclaiming unnecessary disk space, and combining and
splitting values in a transaction. You can read more about these topics in the
original Bitcoin paper~\citep{Nakamoto08}. Further work aims to increase the
rate of transactions  by establishing micropayment channels between two parties
outside the blockchain network~\citep{Decker15}. Lastly, the introduction of a
decentralized system for financial transactions by Bitcoin led to a number of
other blockchain-based cryptocurrencies such as Ethereum~\citep{Buterin14}.

\bibliographystyle{plainnat}
\bibliography{paper.bib}

\end{document}
